# Prisma Setup Guide

Step-by-step guide for setting up and using Prisma in the DSA Solver project.

## Project Structure

This project uses a **modular Prisma schema** approach:
- **`prisma/schema.prisma`** - Contains all enums (TokenType, ProviderType, QuestionType, etc.)
- **`prisma/*.prisma`** - Individual model files (user.prisma, problem.prisma, etc.)
- **`prisma.config.ts`** - Prisma configuration file
- **`lib/generated/prisma/`** - Generated Prisma Client (auto-generated)
- **`lib/prisma-client/index.ts`** - Prisma Client singleton instance

## Initial Setup (First Time)

### Step 1: Install Dependencies

```bash
npm install
```

**Why:** Installs Prisma CLI and all required packages.

### Step 2: Set Up Database Connection

Create `.env` file in root directory:

**For Local PostgreSQL:**
```env
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/dsa-solver?schema=public
```

**For Docker:**
```env
DATABASE_URL=postgresql://postgres:postgres@postgres:5435/postgres?schema=public
```

**Why:** Prisma needs the database connection string to connect to PostgreSQL.

### Step 3: Start Database (If Using Docker)

```bash
npm run docker:up
```

**Why:** Starts PostgreSQL container. Wait until it's healthy before proceeding.

### Step 4: Prisma Configuration

The project uses `prisma.config.ts` for configuration:

```typescript
export default defineConfig({
  schema: "prisma",  // Reads all .prisma files from prisma/ directory
  migrations: {
    path: "prisma/migrations",
    seed: `tsx prisma/seed/seed.ts`
  },
  datasource: {
    url: env("DATABASE_URL"),
  },
});
```

**Why:** This configuration allows Prisma to read multiple schema files from the `prisma/` directory.

### Step 5: Schema Structure

**Enums** are defined in `prisma/schema.prisma`:
- `TokenType` (OTP, REFRESH_TOKEN)
- `TokenPurpose` (LOGIN)
- `ProviderType` (LEETCODE, GFG)
- `DeliveryStatus` (PENDING, SENT, DELIVERED, FAILED, RETRYING)
- `ScheduleType` (DAILY, WEEKLY, CUSTOM)
- `TaskStatus` (PENDING, ACTIVE, PAUSED, COMPLETED, FAILED)
- `ProblemSelection` (RANDOM, DAILY_CHALLENGE, FILTER_BASED, SPECIFIC_PROBLEM)
- `QuestionType` (PROBLEM_OF_THE_DAY, WEEKLY_CHALLENGE, CONTEST_PROBLEM, PRACTICE_PROBLEM, CUSTOM)

**Models** are defined in separate files:
- `prisma/user.prisma` - User model
- `prisma/authToken.prisma` - Authentication tokens
- `prisma/problem.prisma` - Problem/Daily question model
- `prisma/problemLog.prisma` - Problem delivery/submission logs
- `prisma/providerConfig.prisma` - Provider configurations per user
- `prisma/encryptedCredentials.prisma` - Encrypted provider credentials
- `prisma/notificationConfig.prisma` - Email notification settings
- `prisma/scheduledTask.prisma` - Scheduled tasks for automation

**Why:** Modular structure keeps schema organized and maintainable.

### Step 6: Create and Apply Migration

```bash
npm run prisma:migrate
```

When prompted, enter a migration name (e.g., `init`).

**What it does:**
- Creates SQL migration file in `prisma/migrations/`
- Applies changes to your database
- Generates Prisma Client automatically

**Why:** Migrations track database changes over time. This creates your initial database structure.

### Step 7: Generate Prisma Client (If Needed)

```bash
npm run prisma:generate
```

**What it does:** Generates TypeScript types and client in `lib/generated/prisma/`

**Why:** You need the Prisma Client to query your database in code. Usually auto-generated by migrate, but run this if you change schema without migrating.

**Note:** The Prisma Client is automatically generated after migrations, but you may need to run this manually if:
- You pulled code with schema changes
- The client seems out of sync
- Your IDE shows missing types

## Daily Development Workflow

### Making Schema Changes

**Step 1:** Edit the appropriate model file in `prisma/` directory:
- Add new models: Create a new `prisma/<modelName>.prisma` file
- Modify existing models: Edit the corresponding `prisma/<modelName>.prisma` file
- Add/modify enums: Edit `prisma/schema.prisma`

**Step 2:** Create migration:
```bash
npm run prisma:migrate
```
Enter descriptive name (e.g., `add_tokens_used_column`, `add_problem_table`)

**Why:** Creates a migration file that can be version controlled and applied to other environments.

**Step 3:** Use in your code:
```typescript
import prisma from "@/lib/prisma-client";

// Example: Query users
const users = await prisma.user.findMany();

// Example: Create problem
const problem = await prisma.problem.create({
  data: {
    provider: ProviderType.LEETCODE,
    questionType: QuestionType.PROBLEM_OF_THE_DAY,
    problemId: "two-sum",
    // ... other fields
  }
});
```

## Available Commands

### `npm run prisma:generate`

**What:** Generates Prisma Client from schema

**When to use:**
- After pulling code with schema changes
- After manually editing schema
- When types are missing in your IDE

**Why:** Prisma Client is generated code that provides type-safe database access.

---

### `npm run prisma:migrate`

**What:** Creates a new migration and applies it

**When to use:**
- After changing `schema.prisma`
- When you need to update database structure

**Why:** 
- Creates migration file (version control)
- Applies changes to database
- Regenerates Prisma Client

**Note:** Prompts for migration name - use descriptive names like `add_user_table`, `add_email_index`

---

### `npm run prisma:migrate:deploy`

**What:** Applies all pending migrations (doesn't create new ones)

**When to use:**
- In production/staging environments
- When you pulled code with new migrations
- To sync database with latest migrations

**Why:** In production, you only apply existing migrations, not create new ones.

---

### `npm run prisma:migrate:reset`

**What:** Drops database, recreates it, and applies all migrations

**When to use:**
- Development only
- When you want a fresh start
- After major schema changes

**Why:** ⚠️ **Deletes all data!** Useful for development when you want to start clean.

---

### `npm run prisma:studio`

**What:** Opens visual database browser at http://localhost:5555

**When to use:**
- View database data
- Test queries visually
- Debug data issues

**Why:** Provides a GUI to browse and edit database without writing SQL.

---

### `npm run prisma:seed`

**What:** Runs seed script to populate database with initial data

**When to use:**
- After resetting database
- Setting up development environment
- Adding test data

**Why:** Seeds provide consistent initial data for development/testing.

**Setup:** Edit `prisma/seed/seed.ts` to define your seed data.

---

### `npm run prisma:format`

**What:** Auto-formats `schema.prisma` file

**When to use:**
- Before committing schema changes
- When schema looks messy

**Why:** Keeps schema file clean and readable.

---

### `npm run prisma:validate`

**What:** Checks if schema is valid (doesn't apply changes)

**When to use:**
- Before creating migration
- To check for syntax errors

**Why:** Catches errors early without affecting database.

## Current Database Models

### User Model (`prisma/user.prisma`)
- Stores user account information
- Fields: `id`, `email`, `username`, `firstName`, `lastName`, `avatar`, `emailVerified`, `emailVerifiedAt`, `isActive`
- Relations: `providerConfigs`, `scheduledTasks`, `authTokens`, `problemLogs`

### Problem Model (`prisma/problem.prisma`)
- Stores problems/questions from various providers
- Fields: `id`, `provider`, `questionType`, `problemId`, `problemSlug`, `problemUrl`, `title`, `difficulty`, `topics`
- JSON Fields: `description`, `examples`, `constraints`, `solutions`, `explanations`, `hints`
- AI Metadata: `formattedAt`, `aiModel`, `aiConfidence`, `tokensUsed`
- Relations: `logs` (ProblemLog[])
- Unique: `[provider, questionType, problemDate]`

### ProblemLog Model (`prisma/problemLog.prisma`)
- Tracks delivery and submission history for problems
- Fields: `id`, `userId`, `providerConfigId`, `problemId`, `status`, `sentAt`, `emailSent`, `codeSubmitted`, `submissionResult`, `errorMessage`, `retryCount`
- Relations: `user`, `providerConfig`, `problem`
- Unique: `[userId, providerConfigId, problemId]`

### ProviderConfig Model (`prisma/providerConfig.prisma`)
- Per-user, per-provider configurations
- Fields: `id`, `userId`, `provider`, `isActive`
- Relations: `user`, `credentials` (EncryptedCredentials), `notificationConfig`, `scheduledTasks`, `problemLogs`
- Unique: `[userId, provider]`

### AuthToken Model (`prisma/authToken.prisma`)
- Stores OTP and refresh tokens
- Fields: `id`, `userId`, `token`, `tokenType`, `purpose`, `expiresAt`, `usedAt`, `isUsed`, `isRevoked`
- Relations: `user`

### EncryptedCredentials Model (`prisma/encryptedCredentials.prisma`)
- Encrypted provider credentials
- Relations: `providerConfig`

### NotificationConfig Model (`prisma/notificationConfig.prisma`)
- Email notification settings per provider config
- Fields: `id`, `providerConfigId`, `emailEnabled`, `includeExplanation`, `includeBruteForce`, `includeOptimized`, `autoSubmit`, `autoSubmitTime`
- Relations: `providerConfig`

### ScheduledTask Model (`prisma/scheduledTask.prisma`)
- Scheduled automation tasks
- Fields: `id`, `userId`, `providerConfigId`, `scheduleType`, `taskStatus`, `problemSelection`, `nextRunAt`, `lastRunAt`
- Relations: `user`, `providerConfig`

## Common Scenarios

### Scenario 1: Adding a New Model

1. Create new file `prisma/<modelName>.prisma`:
```prisma
// Task Model Schema
// This is the source of truth for the Task model
// Run: npm run prisma:combine to update schema.prisma

model Task {
  id        String   @id @default(cuid())
  title     String
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
}
```

2. Run migration:
```bash
npm run prisma:migrate
# Name: add_task_model
```

3. Use in code:
```typescript
const task = await prisma.task.create({
  data: { title: "My Task" }
});
```

### Scenario 2: Adding a Field to Existing Model

1. Edit the model file (e.g., `prisma/user.prisma`):
```prisma
model User {
  // ... existing fields
  phone String? // Add this
}
```

2. Run migration:
```bash
npm run prisma:migrate
# Name: add_user_phone
```

**Example:** Adding `tokensUsed` to Problem model:
```prisma
// In prisma/problem.prisma
model Problem {
  // ... existing fields
  tokensUsed  Int?  // Number of tokens used for formatting
}
```

### Scenario 3: Adding Relations

1. Edit both model files:
```prisma
// prisma/user.prisma
model User {
  id    String  @id @default(cuid())
  tasks Task[]  // Add relation
}

// prisma/task.prisma
model Task {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])
}
```

2. Run migration:
```bash
npm run prisma:migrate
# Name: add_user_task_relation
```

### Scenario 4: Adding a New Enum

1. Edit `prisma/schema.prisma`:
```prisma
enum Priority {
  LOW
  MEDIUM
  HIGH
}
```

2. Use in model file:
```prisma
// prisma/task.prisma
model Task {
  priority Priority @default(MEDIUM)
}
```

3. Run migration:
```bash
npm run prisma:migrate
# Name: add_priority_enum
```

## Prisma Client Usage

### Import Prisma Client

Always use the singleton instance from `lib/prisma-client`:

```typescript
import prisma from "@/lib/prisma-client";
```

**Why:** The singleton pattern ensures only one Prisma Client instance exists, preventing connection pool exhaustion.

### Example Queries

```typescript
// Create problem
const problem = await prisma.problem.create({
  data: {
    provider: ProviderType.LEETCODE,
    questionType: QuestionType.PROBLEM_OF_THE_DAY,
    problemId: "two-sum",
    problemSlug: "two-sum",
    problemUrl: "https://leetcode.com/problems/two-sum",
    title: "Two Sum",
    difficulty: "Easy",
    topics: ["Array", "Hash Table"],
    problemDate: new Date(),
    tokensUsed: 1500,
    aiModel: "gemini-2.0-flash",
  }
});

// Find problem with relations
const problem = await prisma.problem.findUnique({
  where: {
    provider_questionType_problemDate: {
      provider: ProviderType.LEETCODE,
      questionType: QuestionType.PROBLEM_OF_THE_DAY,
      problemDate: new Date("2025-11-23"),
    }
  },
  include: {
    logs: true
  }
});

// Update problem
const updated = await prisma.problem.update({
  where: { id: problemId },
  data: {
    tokensUsed: 2000,
    formattedAt: new Date(),
  }
});

// Upsert (create or update)
const problem = await prisma.problem.upsert({
  where: {
    provider_questionType_problemDate: {
      provider: ProviderType.LEETCODE,
      questionType: QuestionType.PROBLEM_OF_THE_DAY,
      problemDate: problemDate,
    }
  },
  create: { /* create data */ },
  update: { /* update data */ }
});
```

## Quick Reference

| Task | Command |
|------|---------|
| First time setup | `npm run docker:up` → Edit schema files → `npm run prisma:migrate` |
| Change schema | Edit model file → `npm run prisma:migrate` |
| View database | `npm run prisma:studio` |
| Reset database | `npm run prisma:migrate:reset` |
| Seed data | `npm run prisma:seed` |
| Check schema | `npm run prisma:validate` |
| Regenerate client | `npm run prisma:generate` |

## Important Notes

1. **Modular Schema Structure** - Models are in separate `.prisma` files, enums in `schema.prisma`
2. **Always use migrations** - Never edit database directly
3. **Descriptive names** - Use clear migration names (e.g., `add_tokens_used_column`)
4. **Test locally first** - Always test migrations before production
5. **Version control migrations** - Commit migration files to git
6. **Reset is destructive** - `prisma:migrate:reset` deletes all data
7. **Restart dev server** - After schema changes, restart Next.js dev server to pick up new Prisma Client

## Troubleshooting

**Migration conflicts?**
```bash
npm run prisma:migrate:reset  # Development only - deletes all data!
```

**Client not generated or out of sync?**
```bash
npm run prisma:generate
# Then restart your Next.js dev server
```

**Database connection error?**
- Check `.env` DATABASE_URL
- Verify database is running: `docker-compose ps` or `docker ps`
- Test connection: `npx prisma db pull`

**Field not recognized by Prisma?**
1. Verify field exists in model file (e.g., `prisma/problem.prisma`)
2. Run `npm run prisma:generate`
3. Restart Next.js dev server
4. Check if migration was applied: `npx prisma migrate status`

**Type errors in IDE?**
- Run `npm run prisma:generate`
- Restart TypeScript server in your IDE
- Clear `.next` cache: `rm -rf .next` (then restart dev server)
